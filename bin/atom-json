#!/usr/bin/env python3
import argparse
import json
import os
import itertools as it
from collections import OrderedDict, defaultdict

import numpy as np
from ase import Atoms
from ase import io
from ase.calculators.neighborlist import NeighborList


parser = argparse.ArgumentParser(
        description=" A tool for making structures.json file")
parser.add_argument("-j", dest="path", metavar='N', nargs='+',help="Give the path to the folder containing DFT calculation")
parser.add_argument("-i",dest='dftb', nargs='*',help =" The dftb files")
parser.add_argument("-d",dest='ene', choices=['Elec','Rep','Tene'],type = str,nargs='?',help =" The energy to extract from dftb")
args= parser.parse_args()
print(*zip(args.path,args.dftb)) 

def read_detailedout(files):
    tags=[("Elec","Total Electronic energy:"),("Rep","Repulsive energy"),("Tene","Total energy")]
    tag_values={}
    with open(files) as fp:
        data = fp.readlines()
        for line in data:
            words = line.split()
            for tag in tags:
                if tag[1] in line:
                    tag_values[tag[0]]= float(words[-2])  
    return tag_values


        
        

def pair_dist(atoms, R_c, ch1, ch2):
    ''' This function returns pairwise distances between two types of atoms within a certain cuttoff
    Args:
        R_c (float): Cut off distance(6. Ã…)
        ch1 (str): Atom species 1
        ch2 (str): Atoms species 2

    Returns:
        A list of distances in bohr
    '''
    if ch1 == ch2:

        nl = NeighborList(atoms.get_number_of_atoms() *
                          [R_c], self_interaction=False, bothways=False)
    else:
        nl = NeighborList(atoms.get_number_of_atoms() *
                          [R_c], self_interaction=False, bothways=True)

    nl.update(atoms)
    distances = []
    for j in range(atoms.get_number_of_atoms()):
        if (atoms.get_chemical_symbols()[j] == ch1):
            indices, offsets = nl.get_neighbors(j)
            for i, offset in zip(indices, offsets):
                if(atoms.get_chemical_symbols()[i] == ch2):
                    distances.append((np.linalg.norm(
                        atoms.positions[i] + np.dot(offset, atoms.get_cell()) - atoms.positions[j])))

    distances.sort()
    r_distances = [round(elem*1.88973, 6)
                   for elem in distances] #distance to bohr
    return r_distances


def main(path_dft,path_dftb=None,R_c=3.0):
    """  Function to read files and output structures.json
    
    Args:
        args(list): list of filenames
        R_c (float, optional): Distance cut-off. Defaults to 3.0.
    """
    path = zip(path_dft,path_dftb)
    species = []
    c = OrderedDict()
    d = OrderedDict()
    for counter, filename in enumerate(path):
        print(filename)
        print
        struct = []
        struct = io.read(filename[0])
        c = OrderedDict()
        E = struct.get_potential_energy()
        dict_species = defaultdict(int)
        for elem in struct.get_chemical_symbols():
            dict_species[elem] += 1
        atom_pair = it.combinations_with_replacement(dict_species.keys(), 2)
        c['Energy'] = E
        c['DFTB_energy']=read_detailedout(filename[1])
        c['Atoms'] = dict_species
        for (x, y) in atom_pair:
            pair_distances = pair_dist(struct, R_c, x, y)
            c[str(x)+'-'+str(y)] = pair_distances
        d['S'+str(counter+1)] = c
    with open('structures.json', 'w') as f:
        json.dump(d, f, indent=8)
    
main(args.path,path_dftb=args.dftb) 
